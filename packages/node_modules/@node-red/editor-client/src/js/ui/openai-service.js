/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

RED.openAIService = (function() {
    // OpenAI API configuration
    var config = {
        apiKey: "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" ,
        model: "gpt-4o", // Default model
        temperature: 0.0
    };

    // Function to load configuration from Node-RED settings
    function loadConfig() {
        if (RED.settings && RED.settings.openai) {
            if (RED.settings.openai.apiKey) {
                config.apiKey = RED.settings.openai.apiKey;
            }
            if (RED.settings.openai.model) {
                config.model = RED.settings.openai.model;
            }
            if (RED.settings.openai.temperature !== undefined) {
                config.temperature = RED.settings.openai.temperature;
            }
        }
    }

    // Function to process user messages, either for conversation or flow creation
    async function processMessage(userMessage, conversationHistory, availableNodeTypes) {
        // Check if API key is configured
        if (!config.apiKey) {
            throw new Error("OpenAI API key not configured. Please set it in the settings.");
        }
        
        // Prepare conversation history for OpenAI
        var messages = [
            {
                role: "system",
                content: "You are an AI assistant for Node-RED, a flow-based programming tool. " +
                         "You can help users by answering questions about Node-RED and creating flows. " +
                         "If the user wants to create a flow, use the create_flow function and pass a valid node-red flow json as a string. " +
                         "Otherwise, use the normal_reply function for regular conversation. " +
                         "When generating flows, only include the necessary nodes and do not add trailing newlines to the JSON string."+
                         "Generate names and ids" +
                         "Only use the available node types to create the flow, and don't custom make nodes if there is a node type that already exists: " + JSON.stringify(availableNodeTypes)
                        
            }
        ];

        console.log(messages);
        
        // Add conversation history, but limit to last 10 messages to save tokens
        var recentHistory = conversationHistory.slice(-10);
        messages = messages.concat(recentHistory);
        
        // Add the current request
        messages.push({
            role: "user",
            content: userMessage
        });
        
        // Define the functions we want the model to call
        const functions = [
            {
                name: "normal_reply",
                description: "Used for standard conversation when the user is not requesting a flow to be created",
                parameters: {
                    type: "object",
                    properties: {
                        response: {
                            type: "string",
                            description: "The assistant's response to the user's query"
                        }
                    },
                    required: ["response"]
                }
            },
            {
                name: "create_flow",
                description: "Creates a Node-RED flow based on the user description",
                parameters: {
                    type: "object",
                    properties: {
                        flow: {
                            type: "string",
                            description: "The stringified JSON representation of the Node-RED flow that can be imported directly. Must be a valid JSON string."
                        },
                        explanation: {
                            type: "string",
                            description: "A detailed explanation of the flow, how it works, and any special considerations"
                        }
                    },
                    required: ["flow", "explanation"]
                }
            }
        ];
        
        // Call OpenAI API with function calling
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${config.apiKey}`
            },
            body: JSON.stringify({
                model: config.model,
                messages: messages,
                temperature: config.temperature,
                max_tokens: 4000,
                functions: functions,
                function_call: "auto"
            })
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`OpenAI API Error: ${errorData.error?.message || 'Unknown error'}`);
        }
        
        const data = await response.json();
        console.log(data);
        
        // Process the function call response
        if (data.choices[0].message.function_call) {
            const functionName = data.choices[0].message.function_call.name;
            const functionArgs = JSON.parse(data.choices[0].message.function_call.arguments);
            
            if (functionName === "normal_reply") {
                // Standard conversation response
                return {
                    success: true,
                    isFlow: false,
                    content: functionArgs.response
                };
            } else if (functionName === "create_flow") {
                // Flow creation response
                try {
                    // Parse the flow JSON from the string
                    const flowJson = JSON.parse(functionArgs.flow);
                    
                    return {
                        success: true,
                        isFlow: true,
                        flow: flowJson,
                        description: functionArgs.explanation
                    };
                } catch (e) {
                    console.error("Error parsing flow JSON:", e);
                    return {
                        success: false,
                        isFlow: false,
                        content: "I tried to create a flow but encountered an error in the JSON format. Please try again with a simpler description.",
                        error: e.message
                    };
                }
            }
        } else {
            // Fallback if function calling didn't work
            const assistantResponse = data.choices[0].message.content;
            return {
                success: true,
                isFlow: false,
                content: assistantResponse
            };
        }
    }

    // Legacy function for backward compatibility
    async function createFlow(userMessage, conversationHistory, availableNodeTypes) {
        return processMessage(userMessage, conversationHistory, availableNodeTypes);
    }

    function init() {
        loadConfig();
    }

    return {
        init: init,
        createFlow: createFlow,
        processMessage: processMessage,
        loadConfig: loadConfig
    };
})(); 
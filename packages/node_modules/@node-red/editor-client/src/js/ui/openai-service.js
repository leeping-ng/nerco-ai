/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

RED.openAIService = (function() {
    // Configuration object
    const config = {
        apiKey: "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",
        model: "gpt-4o",
        temperature: 0.0
    };

    // Function to load configuration from Node-RED settings
    function loadConfig() {
        if (RED.settings?.openai) {
            const { apiKey, model, temperature } = RED.settings.openai;
            if (apiKey) config.apiKey = apiKey;
            if (model) config.model = model;
            if (temperature !== undefined) config.temperature = temperature;
        }
    }

    function getSystemPrompt(availableNodeTypes, nodesInWorkspace) {
        return {
            role: "system",
            content: `You are a Node-RED assistant with three primary functions:

1. ANSWER QUESTIONS
   When providing general information, use normal_reply function.
   - Provide Node-RED knowledge, concepts, and functionality explanations
   - Share best practices and optimization tips
   - Help troubleshoot common issues

2. CREATE NEW FLOWS
   When creating a new flow, use create_flow function with valid JSON.
   - Generate complete, importable Node-RED flow JSON from user descriptions
   - Include only necessary nodes from the available node types
   - Ensure all nodes have unique names and IDs
   - Changes that depend on other changes must be added after the changes they depend on. For example, if you want to add a debug node to see the output of an existing function node:
     1. First add the change to create the debug node
     2. Then add the change to update the function node's wires to connect to the new debug node

3. UPDATE EXISTING FLOWS
   When modifying existing flows, use update_flow function with valid JSON.
   - Preserve all existing node IDs
   - Only update node properties as requested
   - Ensure wires are correctly specified for all nodes

WORKSPACE CONTEXT:
${nodesInWorkspace ? `Currently visible nodes: ${JSON.stringify(nodesInWorkspace)}` : 'No nodes currently in workspace'}

AVAILABLE NODE TYPES:
${JSON.stringify(availableNodeTypes)}

CRITICAL REQUIREMENTS:
- Only use node types from the available list above
- Do not create custom nodes when standard nodes will work
- Generate valid, properly formatted JSON
- Wire connections must be flat arrays of strings
- For new flows: generate unique IDs for all nodes
- For updates: preserve all existing node IDs
- Always verify wire connections are correctly specified

RESPONSE FORMAT:
- For general questions: normal_reply(your detailed answer)
- For new flows: create_flow(valid JSON string with complete flow)
- For flow updates: update_flow(valid JSON string with updated flow and explanation)`
        };
    }

    function prepareMessages(userMessage, conversationHistory, availableNodeTypes, nodesInWorkspace) {
        const messages = [getSystemPrompt(availableNodeTypes, nodesInWorkspace)];
        const recentHistory = conversationHistory.slice(-10);
        return [...messages, ...recentHistory, {
            role: "user",
            content: userMessage
        }];
    }

    function getFunctionDefinitions() {
        return [
            {
                name: "normal_reply",
                description: "Used for standard conversation when the user is not requesting a flow to be created",
                parameters: {
                    type: "object",
                    properties: {
                        response: {
                            type: "string",
                            description: "The assistant's response to the user's query"
                        }
                    },
                    required: ["response"]
                }
            },
            {
                name: "create_flow",
                description: "Creates a Node-RED flow based on the user description",
                parameters: {
                    type: "object",
                    properties: {
                        flow: {
                            type: "string",
                            description: "The stringified JSON representation of the Node-RED flow that can be imported directly. Must be a valid JSON string."
                        },
                        explanation: {
                            type: "string",
                            description: "A detailed explanation of the flow, how it works, and any special considerations"
                        }
                    },
                    required: ["flow", "explanation"]
                }
            },
            {
                name: "update_flow",
                description: "Updates an existing flow based on the user description",
                parameters: {
                    type: "object",
                    properties: {
                        response_to_user: {
                            type: "string",
                            description: "A normal response to the user"
                        },
                        updates: {
                            type: "array",
                            description: "A list of changes to make to the flow. Order is important. Changes that depend on other changes must be added after the changes they depend on. For example, if you need to refrence a node that is created in the  update, add the create node change first, then the update node change.",
                            items: {
                                type: "object",
                                properties: {
                                    nodeId: {type: "string"},
                                    node_json: {type: "string", description: "The Node Red JSON representation of the node to be updated or Added. Leave empty if node is to be removed. Add wires property which is: List of node ids that will be used as an input to the node. For example, a debug node will need a list of nodes that will be connected to it to show their output. Leave empty if no wires are needed."},
                                    change_explanation: {type: "string"},
                                    change_type: {type: "string", enum: ["add", "remove", "modify"]},
                                },
                                required: ["nodeId", "change_explanation", "change_type", "node_json", "wires"]
                            }
                        }
                    },
                    required: ["response_to_user", "updates"]
                }
            }
        ];
    }

    async function callOpenAIAPI(messages) {
        if (!config.apiKey) {
            throw new Error("OpenAI API key not configured. Please set it in the settings.");
        }

        const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${config.apiKey}`
            },
            body: JSON.stringify({
                model: config.model,
                messages: messages,
                temperature: config.temperature,
                functions: getFunctionDefinitions(),
                function_call: "auto"
            })
        });

        const responseData = await response.json();
        console.log(responseData, "response");
        if (!response.ok) {
            throw new Error(`OpenAI API Error: ${responseData.error?.message || 'Unknown error'}`);
        }

        return responseData;
    }

    function handleNormalReply(functionArgs) {
        return {
            success: true,
            isFlow: false,
            isUpdate: false,
            content: functionArgs.response
        };
    }

    function handleCreateFlow(functionArgs) {
        try {
            const flowJson = JSON.parse(functionArgs.flow);
            return {
                success: true,
                isFlow: true,
                flow: flowJson,
                description: functionArgs.explanation
            };
        } catch (e) {
            console.error("Error parsing flow JSON:", e);
            return {
                success: false,
                isFlow: false,
                content: "I tried to create a flow but encountered an error in the JSON format. Please try again with a simpler description.",
                error: e.message
            };
        }
    }

    function handleUpdateFlow(functionArgs) {

        console.log(functionArgs, "functionArgs")

        updates = functionArgs.updates.map(update => {
            return {
                nodeId: update.nodeId,
                change_explanation: update.change_explanation,
                change_type: update.change_type,
                node_json: JSON.parse(update.node_json)
            }
        })

        try {
            return {
                success: true,
                isFlow: false,
                isUpdate: true,
                flow: functionArgs.flow,
                changes: updates,
                response_to_user: functionArgs.response_to_user
            };
        } catch (e) {
            return {
                success: false,
                isFlow: false,
                isUpdate: true,
                content: "I tried to update a flow but encountered an error in the JSON format. Please try again with a simpler description."
            };
        }
    }

    async function processMessage(userMessage, conversationHistory, availableNodeTypes, nodesInWorkspace) {
        const messages = prepareMessages(userMessage, conversationHistory, availableNodeTypes, nodesInWorkspace);
        const data = await callOpenAIAPI(messages);
        
        if (data.choices[0].message.function_call) {
            const { name, arguments: args } = data.choices[0].message.function_call;
            const functionArgs = JSON.parse(args);

            const handlers = {
                normal_reply: handleNormalReply,
                create_flow: handleCreateFlow,
                update_flow: handleUpdateFlow
            };

            return handlers[name]?.(functionArgs) || handleNormalReply({ response: data.choices[0].message.content });
        }

        return {
            success: true,
            isFlow: false,
            isUpdate: false,
            content: data.choices[0].message.content
        };
    }

    // Legacy support
    async function createFlow(userMessage, conversationHistory, availableNodeTypes) {
        return processMessage(userMessage, conversationHistory, availableNodeTypes);
    }

    function init() {
        loadConfig();
    }

    return {
        init,
        createFlow,
        processMessage,
        loadConfig
    };
})(); 
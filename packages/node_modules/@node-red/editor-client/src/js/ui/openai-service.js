/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

RED.openAIService = (function() {
    // Configuration object
    const config = {
        apiKey: "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",
        model: "claude-3-7-sonnet-20250219",
        temperature: 0.3
    };

    // Function to load configuration from Node-RED settings
    function loadConfig() {
        if (RED.settings?.openai) {
            const { apiKey, model, temperature } = RED.settings.openai;
            if (apiKey) config.apiKey = apiKey;
            if (model) config.model = model;
            if (temperature !== undefined) config.temperature = temperature;
        }
    }

    function getSystemPrompt(availableNodeTypes, nodesInWorkspace) {
        return {
            role: "system",
            content: `You are a Node-RED assistant with three primary functions:

1. ANSWER QUESTIONS
   When providing general information, use normal_reply function.
   - Provide Node-RED knowledge, concepts, and functionality explanations
   - Share best practices and optimization tips
   - Help troubleshoot common issues

2. CREATE NEW FLOWS
   When creating a new flow, use create_flow function with valid JSON.
   - Generate complete, importable Node-RED flow JSON from user descriptions
   - Include only necessary nodes from the available node types
   - Ensure all nodes have unique names and IDs
   - Changes that depend on other changes must be added after the changes they depend on. For example, if you want to add a debug node to see the output of an existing function node:
     1. First add the change to create the debug node
     2. Then add the change to update the function node's wires to connect to the new debug node

3. UPDATE EXISTING FLOWS
   When modifying existing flows, use update_flow function with valid JSON.
   - Preserve all existing node IDs
   - Generate the operations one by one as shown in the function definitions.
   - Ensure wires are correctly specified for all nodes
   - Preserve the position of the nodes if it wasn't explicitly changed.

WORKSPACE CONTEXT:
${nodesInWorkspace ? `Currently visible nodes: ${JSON.stringify(nodesInWorkspace)}` : 'No nodes currently in workspace'}

AVAILABLE NODE TYPES:
${JSON.stringify(availableNodeTypes)}

CRITICAL REQUIREMENTS:
- Only use node types from the available list above
- Do not create custom nodes when standard nodes will work
- Generate valid, properly formatted JSON
- Wire connections must be flat arrays of strings
- For new flows: generate unique IDs for all nodes
- For updates: preserve all existing node IDs
- Always verify wire connections are correctly specified

RESPONSE FORMAT:
- For general questions: normal_reply(your detailed answer)
- For new flows: create_flow(valid JSON string with complete flow)
- For flow updates: update_flow(valid JSON string with updated flow and explanation)`
        };
    }

    function prepareMessages(userMessage, conversationHistory, availableNodeTypes, nodesInWorkspace) {
        const recentHistory = conversationHistory.slice(-1000);
        return [...recentHistory, {
            role: "user",
            content: userMessage
        }];
    }

    function getFunctionDefinitions() {
        return [
            {
                name: "normal_reply",
                description: "Used for standard conversation when the user is not requesting a flow to be created",
                input_schema: {
                    type: "object",
                    properties: {
                        response: {
                            type: "string",
                            description: "The assistant's response to the user's query"
                        }
                    },
                    required: ["response"]
                }
            },
            {
                name: "create_flow",
                description: "Creates a Node-RED flow based on the user description",
                input_schema: {
                    type: "object",
                    properties: {
                        flow: {
                            type: "string",
                            description: "The stringified JSON representation of the Node-RED flow that can be imported directly. Must be a valid JSON string."
                        },
                        explanation: {
                            type: "string",
                            description: "A detailed explanation of the flow, how it works, and any special considerations"
                        }
                    },
                    required: ["flow", "explanation"]
                }
            },
            {
                name: "update_flow",
                description: "Updates an existing flow using git-like change operations",
                input_schema: {
                    type: "object",
                    properties: {
                        changes: {
                            type: "array",
                            description: "List of git-like operations to apply to the flow",
                            items: {
                                type: "object",
                                properties: {
                                    operation: {
                                        type: "string",
                                        enum: ["add", "modify", "remove"],
                                        description: "Type of change operation"
                                    },
                                    nodeId: {
                                        type: "string",
                                        description: "ID of the node being modified"
                                    },
                                    value: {
                                        type: "string",
                                        description: "Entire Stringified JSON of the node to be added or modified"
                                    },
                                    description: {
                                        type: "string",
                                        description: "Description of the change"
                                    }
                                },
                                required: ["operation", "nodeId", "value", "description"]
                            }
                        },
                        explanation: {
                            type: "string",
                            description: "Overall explanation of the changes shown to the user"
                        }
                    },
                    required: ["changes", "explanation"]
                }
            }
        ];
    }

    async function callOpenAIAPI(messages, availableNodeTypes, nodesInWorkspace) {
        if (!config.apiKey) {
            throw new Error("OpenAI API key not configured. Please set it in the settings.");
        }

        last_message = messages[messages.length - 1];
        last_message = last_message + "\n\nIMPORTANT: If you are updating a flow, you must include the entire flow json in the flow property. Do not generate partial updates. If a flow is not being changed, include it in the update flow. We will take the entir flow json and import it.";
        last_message = last_message + "\n\nIMPORTANT: Beautify always the workflow based on the position and subflows";
        const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': config.apiKey,
                'anthropic-dangerous-direct-browser-access': true,
                'anthropic-version': '2023-06-01'
            },
            body: JSON.stringify({
                model: config.model,
                messages: messages,
                temperature: config.temperature,
                tools: getFunctionDefinitions(),
                max_tokens: 4000,
                system: getSystemPrompt(availableNodeTypes, nodesInWorkspace).content
            })
        });

        const responseData = await response.json();
        console.log(responseData, "response");
        if (!response.ok) {
            throw new Error(`OpenAI API Error: ${responseData.error?.message || 'Unknown error'}`);
        }

        return responseData;
    }

    function handleNormalReply(functionArgs, nodesInWorkspace) {
        return {
            success: true,
            isFlow: false,
            isUpdate: false,
            content: functionArgs.response
        };
    }

    function handleCreateFlow(functionArgs, nodesInWorkspace) {
        try {
            const flowJson = JSON.parse(functionArgs.flow);
            return {
                success: true,
                isFlow: true,
                flow: flowJson,
                description: functionArgs.explanation
            };
        } catch (e) {
            console.error("Error parsing flow JSON:", e);
            return {
                success: false,
                isFlow: false,
                content: "I tried to create a flow but encountered an error in the JSON format. Please try again with a simpler description.",
                error: e.message
            };
        }
    }

    function handleUpdateFlow(functionArgs, nodesInWorkspace) {
        console.log(functionArgs.changes, "changes");
        try {
            // Ensure changes are properly sanitized before processing
            const sanitizedChanges = functionArgs.changes.map(change => {
                // Clone the change object to avoid modifying the original
                const sanitizedChange = {...change};
                
                // If value exists and is a string, ensure it's valid JSON
                if (sanitizedChange.value && typeof sanitizedChange.value === 'string') {
                    try {
                        // Test parse to ensure valid JSON
                        JSON.parse(sanitizedChange.value);
                    } catch (e) {
                        // If parsing fails, try to sanitize the string
                        sanitizedChange.value = sanitizedChange.value
                            .replace(/[\u0000-\u001F\u007F-\u009F]/g, "") // Remove control characters
                            .replace(/\\(?!["\\/bfnrt])/g, "\\\\"); // Escape backslashes properly
                    }
                }
                return sanitizedChange;
            });
            
            flow = applyFlowChanges(nodesInWorkspace, sanitizedChanges);
            console.log(flow, "flow");
            return {
                success: true,
                isFlow: false,
                isUpdate: true,
                flow: flow,
                changes: sanitizedChanges.map(change => ({
                    ...change,
                    timestamp: Date.now(),
                    status: 'pending'
                })),
                description: functionArgs.explanation
            };
        } catch (e) {
            console.error("Error in handleUpdateFlow:", e);
            return {
                success: false,
                isFlow: false,
                isUpdate: true,
                content: "Error processing flow updates: " + e.message
            };
        }
    }

    // Add new utility function to apply changes
    function applyFlowChanges(currentFlow, changes) {
        const newFlow = currentFlow;

        changes.forEach(change => {
            const { operation, nodeId } = change;
            let nodeValue;
            
            try {
                if (change.value && change.value !== "") {
                    nodeValue = JSON.parse(change.value);
                } else {
                    nodeValue = "";
                }
            } catch (e) {
                console.error(`Error parsing value for node ${nodeId}:`, e);
                return; // Skip this change if parsing fails
            }

            switch (operation) {
                case 'add':
                    // Add new node to the flow
                    newFlow.push(nodeValue);
                    break;
                    
                case 'modify':
                    // Find and update existing node
                    const nodeIndex = newFlow.findIndex(node => node.id === nodeId);
                    if (nodeIndex !== -1) {
                        newFlow[nodeIndex] = { ...newFlow[nodeIndex], ...nodeValue };
                    } else {
                        console.log("Couldn't find node", nodeId);
                    }
                    break;
                    
                case 'remove':
                    // Remove node from flow
                    const deleteIndex = newFlow.findIndex(node => node.id === nodeId);
                    if (deleteIndex !== -1) {
                        newFlow.splice(deleteIndex, 1);
                    } else {
                        console.log("Couldn't find node", nodeId);
                    }
                    break;
            }
        });

        return newFlow;
    }

    async function processMessage(userMessage, conversationHistory, availableNodeTypes, nodesInWorkspace) {
        const messages = prepareMessages(userMessage, conversationHistory, availableNodeTypes, nodesInWorkspace);
        const data = await callOpenAIAPI(messages, availableNodeTypes, nodesInWorkspace);
        
        if (data.content && Array.isArray(data.content)) {
            for (const item of data.content) {
                if (item.type === 'tool_use') {
                    const { name, input } = item;
                    const functionArgs = input;

                    const handlers = {
                        normal_reply: handleNormalReply,
                        create_flow: handleCreateFlow,
                        update_flow: handleUpdateFlow
                    };

                    return handlers[name]?.(functionArgs, nodesInWorkspace) || 
                           handleNormalReply({ response: "I couldn't process your request properly." }, nodesInWorkspace);
                } 
            }
        }

        return {
            success: true,
            isFlow: false,
            isUpdate: false,
            content: data.content[0].text
        };
    }

    // Legacy support
    async function createFlow(userMessage, conversationHistory, availableNodeTypes) {
        return processMessage(userMessage, conversationHistory, availableNodeTypes);
    }

    function init() {
        loadConfig();
    }

    return {
        init,
        createFlow,
        processMessage,
        loadConfig,
        applyFlowChanges
    };
})(); 
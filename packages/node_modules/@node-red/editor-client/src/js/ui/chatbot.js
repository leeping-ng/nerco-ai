/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

RED.chatbot = (function() {
    var content = null;
    var chatContainer = null;
    var messageContainer = null;
    var inputContainer = null;
    var chatHistory = [];
    var isProcessing = false;

    function createChatbotContent() {
        content = $('<div class="red-ui-chatbot"></div>');
        chatContainer = $('<div class="red-ui-chatbot-container"></div>').appendTo(content);
        messageContainer = $('<div class="red-ui-chatbot-messages"></div>').appendTo(chatContainer);
        
        // Add welcome message
        addSystemMessage("Hi ðŸ‘‹ I can help you create flows or answer questions about Node-RED. Ask me anything or describe a flow you'd like to build.");
        
        // Input area
        inputContainer = $('<div class="red-ui-chatbot-input"></div>').appendTo(chatContainer);
        var textarea = $('<textarea class="red-ui-chatbot-textarea" placeholder="Ask a question or describe a flow you want to create..."></textarea>').appendTo(inputContainer);
        var buttonContainer = $('<div class="red-ui-chatbot-buttons"></div>').appendTo(inputContainer);
        var sendButton = $('<button class="red-ui-button red-ui-chatbot-send">Send</button>').appendTo(buttonContainer);
        
        // Event handlers
        textarea.on('keydown', function(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        });
        
        sendButton.on('click', function() {
            sendMessage();
        });
        
        function sendMessage() {
            if (isProcessing) return;
            
            var message = textarea.val().trim();
            if (message.length === 0) return;
            
            addUserMessage(message);
            textarea.val('');
            
            // Process the message
            processUserMessage(message);
        }
        
        return content;
    }
    
    function addUserMessage(message) {
        var userMessage = $('<div class="red-ui-chatbot-message red-ui-chatbot-message-user"></div>')
            .appendTo(messageContainer);
        $('<div class="red-ui-chatbot-message-text"></div>')
            .text(message)
            .appendTo(userMessage);
        
        chatHistory.push({ role: 'user', content: message });
        scrollToBottom();
    }
    
    function addSystemMessage(message) {
        var systemMessage = $('<div class="red-ui-chatbot-message red-ui-chatbot-message-system"></div>')
            .appendTo(messageContainer);
        
        // For debugging - log the raw message and parsed content
        var parsedContent = marked(message);
        
        $('<div class="red-ui-chatbot-message-text"></div>')
            .html(parsedContent)
            .appendTo(systemMessage);
        
        if (message !== "Welcome to Node-RED Assistant! I can help you create flows or answer questions about Node-RED. Ask me anything or describe a flow you'd like to build.") {
            chatHistory.push({ role: 'assistant', content: message });
        }
        scrollToBottom();
    }
    
    function addFlowMessage(flowJson, flowDescription) {
        var flowMessage = $('<div class="red-ui-chatbot-message red-ui-chatbot-message-flow"></div>')
            .appendTo(messageContainer);
        
        // Parse markdown and log for debugging
        var parsedContent = marked(flowDescription);
        
        $('<div class="red-ui-chatbot-message-text"></div>')
            .html(parsedContent)
            .appendTo(flowMessage);
        
        var flowActionContainer = $('<div class="red-ui-chatbot-flow-actions"></div>')
            .appendTo(flowMessage);
        
        $('<button class="red-ui-button red-ui-button-small">Insert Flow</button>')
            .on('click', function() {
                insertFlow(flowJson);
            })
            .appendTo(flowActionContainer);
        
        scrollToBottom();
    }
    
    function scrollToBottom() {
        messageContainer.scrollTop(messageContainer[0].scrollHeight);
    }

    function update_links(nodesInWorkspace) {

        node_targets = {};
        nodesInWorkspace.forEach(node => {
            console.log(RED.nodes.getNodeLinks(node.id, 1), "linkss");
            wires = RED.nodes.getNodeLinks(node.id, 1).map(link => {
                if (!node_targets[link.source.id]) {
                    node_targets[link.source.id] = [];
                }
                node_targets[link.source.id].push(link.target.id);
            });
            console.log(node_targets, "node_targets");
        });
        nodesInWorkspace.forEach(node => {
            node.wires = node_targets[node.id];
        });

    }

    function processUserMessage(message) {
        isProcessing = true;
        
        // Show typing indicator
        var processingMessage = $('<div class="red-ui-chatbot-message red-ui-chatbot-message-system red-ui-chatbot-message-typing"></div>')
            .appendTo(messageContainer);
        $('<div class="red-ui-chatbot-message-text">Thinking...</div>')
            .appendTo(processingMessage);
        scrollToBottom();
        
        // Get available node types for context
        var nodeTypes = RED.nodes.registry.getNodeDefinitions();
        
        const activeTabId = RED.workspaces.active();
        const nodesInWorkspace = RED.nodes.filterNodes({z: activeTabId});

        // Create a safe copy of nodes without circular references
        const safeNodes = nodesInWorkspace.map(node => {
            const safeCopy = {};
            const safeProps = ['id', 'type', 'name', 'z', 'x', 'y', 'wires'];
            safeProps.forEach(prop => {
                if (node[prop] !== undefined) {
                    safeCopy[prop] = JSON.parse(JSON.stringify(node[prop]));
                }
            });
            return safeCopy;
        });

        update_links(safeNodes);

        // Get the response from OpenAI service with safe copies
        RED.openAIService.processMessage(message, chatHistory, nodeTypes, safeNodes)
            .then(function(result) {
                console.log(result, "result");
                processingMessage.remove();
                
                if (result.success) {
                    if (result.isFlow) {
                        // Add the flow message with insert action
                        addFlowMessage(result.flow, result.description);
                        
                        // Add to chat history
                        chatHistory.push({ 
                            role: 'assistant', 
                            content: result.description 
                        });
                    } 
                    else if (result.isUpdate) {
                        // Add update flow response
                        updateFlowMessage(result.changes, result.response_to_user, activeTabId);
                    }
                    else {
                        // Add normal conversation response
                        addSystemMessage(result.content);
                    }
                } else {
                    // Add error message
                    addSystemMessage("I'm sorry, an error occurred: " + (result.error || "Unknown error"));
                }
                
                isProcessing = false;
            })
            .catch(function(error) {
                processingMessage.remove();
                console.error("Error processing message:", error);
                addSystemMessage("I'm sorry, an error occurred while processing your message. Please try again later.");
                isProcessing = false;
            });
    }

    function insertFlow(flowJson) {
        // Convert the flow to the format expected by Node-RED
        // Use RED.view to import the nodes at the current mouse position
        console.log(flowJson, "flowJson");

        change_ids(flowJson);
        RED.view.importNodes(flowJson, {
            addFlow: false,
            touchImport: false,
            generateIds: false,
            generateDefaultNames: false
        });
        
        // Add confirmation message
        addSystemMessage("Flow has been added to the workspace!");
    }

    function change_ids(flowJson) {
        current_ids_to_new_ids = {};
        for (var i = 0; i < flowJson.length; i++) {
            current_ids_to_new_ids[flowJson[i].id] = RED.nodes.id();
        }
        for (var i = 0; i < flowJson.length; i++) {
            flowJson[i].id = current_ids_to_new_ids[flowJson[i].id];
            if (flowJson[i].wires !== undefined) {
                if (flowJson[i].wires.length > 0 && Array.isArray(flowJson[i].wires[0])) {
                    // Handle nested array case
                    for (var j = 0; j < flowJson[i].wires.length; j++) {
                        for (var k = 0; k < flowJson[i].wires[j].length; k++) {
                            flowJson[i].wires[j][k] = current_ids_to_new_ids[flowJson[i].wires[j][k]];
                        }
                    }
                } else {
                    // Handle flat array case
                    for (var j = 0; j < flowJson[i].wires.length; j++) {
                        flowJson[i].wires[j] = current_ids_to_new_ids[flowJson[i].wires[j]];
                    }
                }
            }
        }
    }

    function updateFlowMessage(changes, response_to_user, activeTabId) {
        var flowMessage = $('<div class="red-ui-chatbot-message red-ui-chatbot-message-flow"></div>')
            .appendTo(messageContainer);
        var parsedContent = marked(response_to_user);
        // Add general explanation
        $('<div class="red-ui-chatbot-message-text"></div>')
            .html(parsedContent)
            .appendTo(flowMessage);

        // Add changes list
        var changesList = $('<div class="red-ui-chatbot-changes-list"></div>')
            .appendTo(flowMessage);
        
        // Process each change
        changes.forEach(function(change) {
            var changeItem = $('<div class="red-ui-chatbot-change-item"></div>')
                .appendTo(changesList);
            
            // Add colored dot based on change type
            var dotColor;
            switch(change.change_type) {
                case 'add':
                    dotColor = '#2ecc71'; // green
                    break;
                case 'remove':
                    dotColor = '#e74c3c'; // red
                    break;
                case 'modify':
                    dotColor = '#f1c40f'; // orange
                    break;
            }
            
            $('<span class="red-ui-chatbot-change-dot"></span>')
                .css({
                    'background-color': dotColor,
                    'display': 'inline-block',
                    'width': '8px',
                    'height': '8px',
                    'border-radius': '50%',
                    'margin-right': '8px'
                })
                .appendTo(changeItem);
            
            // Add change explanation
            $('<span></span>')
                .text(change.change_explanation)
                .appendTo(changeItem);
        });
        
        var flowActionContainer = $('<div class="red-ui-chatbot-flow-actions"></div>')
            .appendTo(flowMessage);
        
        // Add update button
        $('<button class="red-ui-button red-ui-button-small">Update Flow</button>')
            .on('click', function() {
                updateFlow(changes, activeTabId);
            })
            .appendTo(flowActionContainer);
        
        scrollToBottom();
    }
    
    function sortChangesByDependencies(changes, existingNodes) {
        // Create a map of existing node IDs for quick lookup
        const existingNodeIds = new Set(existingNodes.map(n => n.id));

        // Sort changes so nodes that are dependencies get created first
        return [...changes].sort((a, b) => {
            // If either change is a remove, no dependencies to worry about
            if (a.change_type === 'remove' || b.change_type === 'remove') {
                return 0;
            }

            // Get the wires arrays directly since node_json is already parsed
            const aWires = a.node_json.wires || [];
            const bWires = b.node_json.wires || [];
            
            // Get all wire dependencies (flattened array of target node IDs)
            const aDeps = [].concat(...aWires);
            const bDeps = [].concat(...bWires);

            // Check if a depends on b
            if (aDeps.includes(b.nodeId)) {
                return 1; // b should come before a
            }
            
            // Check if b depends on a
            if (bDeps.includes(a.nodeId)) {
                return -1; // a should come before b
            }

            // If a needs nodes that don't exist yet, it should come later
            const aNeedsMissing = aDeps.some(id => !existingNodeIds.has(id) && !changes.find(c => c.nodeId === id));
            const bNeedsMissing = bDeps.some(id => !existingNodeIds.has(id) && !changes.find(c => c.nodeId === id));

            if (aNeedsMissing && !bNeedsMissing) {
                return 1;
            }
            if (!aNeedsMissing && bNeedsMissing) {
                return -1;
            }

            return 0;
        });
    }

    function updateFlow(changes, activeTabId) {
        // First ensure flowJson is in array format
        const nodesInWorkspace = RED.nodes.filterNodes({z: activeTabId});
        changes = sortChangesByDependencies(changes, nodesInWorkspace);

        console.log(changes, "sorted changes");
        // Process changes sequentially with delays
        function processChange(index) {
            if (index >= changes.length) {
                return; // All changes processed
            }

            const change = changes[index];
            
            if (change.change_type === 'add') {

                if(change.node_json.wires.length > 0 && Array.isArray(change.node_json.wires[0])){
                    change.node_json.wires = [].concat(...change.node_json.wires);
                    console.log(change.node_json.wires, "flattened wires");
                }

                RED.view.importNodes(change.node_json, {
                    addFlow: false,
                    touchImport: true,
                    generateIds: false,
                    generateDefaultNames: false
                });
                // Wait for 500ms before processing next change
                setTimeout(() => processChange(index + 1), 100);
            }
            else if (change.change_type === 'modify') {
                console.log(nodesInWorkspace.filter(node => node.id === change.nodeId));
                let node = nodesInWorkspace.filter(node => node.id === change.nodeId)[0];
                console.log(node, "nodeeeeeeee");
                
                // Create an edit state to track changes
                let editState = {
                    changes: {},
                    changed: false
                };
                
                // Store the old state for history
                for (let prop in change.node_json) {
                    if (node.hasOwnProperty(prop)) {
                        if ( node[prop] !== undefined){
                            editState.changes[prop] = JSON.parse(JSON.stringify(node[prop]));
                        }
                    }
                }
                
                // Remove only outgoing links (where this node is the source)
                let removedLinks = [];
                RED.nodes.eachLink(function(link) {
                    if (link.source === node) {
                        console.log(link, "link hi");
                        removedLinks.push(link);
                    }
                });
                
                // Remove the old outgoing links
                for (let link of removedLinks) {
                    RED.nodes.removeLink(link);
                }
                
                // Apply all changes from node_json
                for (let prop in change.node_json) {
                    if (prop === '_config' || prop === '_def'){
                        console.log(prop, "prop");
                        continue;
                    }
                    node[prop] = change.node_json[prop];
                }
                
                // Add new outgoing links based on the wires property
                if (node.wires && Array.isArray(node.wires)) {
                    // node.wires is an array where each element is an array of target nodes
                    // The index in the outer array represents which output of the node to use
                    node.wires.forEach(targetNode => {
                        if (Array.isArray(targetNode)){
                            targetNode.forEach(target => {
                                console.log(target, "targetNode before 1");
                                target = RED.nodes.filterNodes({z: activeTabId}).filter(node => node.id === target)[0];
                                console.log(target, "targetNode after 1");
                                RED.nodes.addLink({
                                    source: node,
                                    sourcePort: 0,
                                    target: target,
                                    targetPort: 0
                                });
                            });
                        }
                        else{
                            console.log(targetNode, "targetNode hii 2");
                            target = RED.nodes.filterNodes({z: activeTabId}).filter(node => node.id === targetNode)[0];
                            console.log(target, "got target");
                            RED.nodes.addLink({
                                source: node,
                                sourcePort: 0,
                                target: target,
                                targetPort: 0
                            });
                        }
                    });
                }


                // Mark as changed
                editState.changed = true;
                
                // Update node properties and trigger necessary events
                RED.editor.updateNodeProperties(node);
                RED.events.emit("nodes:change", node);
                RED.nodes.dirty();
                RED.history.push({
                    t: 'edit',
                    node: node,
                    changes: editState.changes,
                    dirty: RED.nodes.dirty()
                });
                RED.view.redraw(true);
                setTimeout(() => {
                    RED.view.redraw(true);
                }, 100);
                console.log("Redrew");

                // Wait for 500ms before processing next change
                setTimeout(() => processChange(index + 1), 500);
            }
        }

        // Start processing changes
        processChange(0);
    }

    function init() {
        // Initialize the OpenAI service
        RED.openAIService.init();

        // Create tab content
        var sidebarContent = createChatbotContent();
        
        // Add the tab to the sidebar
        RED.sidebar.addTab({
            id: "chatbot",
            label: "Assistant",
            name: "Node-RED Assistant",
            content: sidebarContent,
            iconClass: "fa fa-comments",
            enableOnEdit: true
        });
    }

    return {
        init: init
    };
})(); 